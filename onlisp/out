11.lisp:(defun ret+ ()
11.lisp:(defun condlet-clause (vars cl bodfn)
11.lisp:(defun condlet-binds (vars cl)
11.lisp:(defun >casex (g cl)
12.5.lisp:  (defun retrieve (key)
13.lisp:(defun avg1 (&rest args)
13.lisp:(defun most-of1 (&rest args)
13.lisp:(defun nthmost1 (n lst)
14.lisp:(defun count-instances (obj lists)
14.lisp:  (defun edible? (x)
14.lisp:  (defun edible? (x)
14.lisp:  (defun read2 (&optional (str *standard-input*))
14.lisp:(defun our-load (filename)
15.lisp:(defun rbuild (expr)
15.lisp:(defun build-call (op fns)
15.lisp:(defun build-compose (fns)
15.lisp:(defun our-length (lst)
15.lisp:(defun our-every (fn lst)
15.lisp:(defun our-copy-list (lst)
15.lisp:(defun our-remove-duplicates (lst)
15.lisp:(defun our-find-if (fn lst)
15.lisp:(defun our-some (fn lst)
15.lisp:(defun unions (&rest sets)
15.lisp:(defun intersections (&rest sets)
15.lisp:(defun differences (set &rest outs)
15.lisp:(defun maxmin (args)
15.lisp:(defun our-copy-tree (tree)
15.lisp:(defun count-leaves (tree)
15.lisp:(defun flatten (tree)
15.lisp:(defun rfind-if (fn tree)
15.lisp:(defun force (x)
16.2.lisp:(defun anaphex1 (args call)
16.2.lisp:(defun anaphex2 (op args)
16.2.lisp:(defun anaphex3 (op args)
16.2.lisp:(defun pop-symbol (sym)
16.lisp:(defun a+expand (args syms)
16.lisp:(defun alist-expand (args syms)
16.lisp:(defun mass-cost (menu-price)
16.lisp:(defun anaphex (args expr)
16.lisp:(defun pop-symbol (sym)
16.lisp:(defun mass-cost (menu-price)
17.lisp:  (defun ddfn (left right fn)
18.lisp:(defun destruc (pat seq &optional (atom? #'atom) (n 0))
18.lisp: (defun dbind-ex (binds body)
18.lisp:(defun wplace-ex (binds body)
18.lisp:(defun match (x y &optional binds)
18.lisp:(defun varsym? (x)
18.lisp:(defun binding (x binds)
18.lisp:(defun vars-in (expr &optional (atom? #'atom))
18.lisp:(defun var? (x)
18.lisp:(defun abab (seq)
18.lisp:(defun simple? (x) (or (atom x) (eq (car x) 'quote)))
18.lisp:(defun gen-match (refs then else)
18.lisp:(defun match1 (refs then else)
18.lisp:(defun gensym? (s)
18.lisp:(defun length-test (pat rest)
18.lisp:(defun abab (seq)
19.1.lisp:(defun match (x y &optional binds)
19.1.lisp:(defun varsym? (x)
19.1.lisp:(defun binding (x binds)
19.1.lisp:(defun vars-in (expr &optional (atom? #'atom))
19.1.lisp:(defun var? (x)
19.1.lisp:(defun make-db (&optional (size 100))
19.1.lisp:(defun clear-db (&optional (db *default-db*))
19.1.lisp:(defun db-push (key val &optional (db *default-db*))
19.1.lisp:(defun interpret-query (expr &optional binds)
19.1.lisp:(defun interpret-and (clauses binds)
19.1.lisp:(defun interpret-or (clauses binds)
19.1.lisp:(defun interpret-not (clause binds)
19.1.lisp:(defun lookup (pred args &optional binds)
19.lisp:(defun make-db (&optional (size 100))
19.lisp:(defun clear-db (&optional (db *default-db*))
19.lisp:(defun db-push (key val &optional (db *default-db*))
2.lisp:(defun double (x) (* x 2))
2.lisp:  (defun double (x) (* x 2))
2.lisp:  (defun our-remove-if (fn lst &optional acc)
2.lisp:  (defun behave (animal)
2.lisp:  (defun behave (animal)
2.lisp:    (defun scope-test (x)
2.lisp:  (defun list+ (lst n)
2.lisp:    (defun new-id () (incf counter))
2.lisp:    (defun reset-id () (setq counter 0)))
2.lisp:  (defun make-adder (n)
2.lisp:  (defun make-adderb (n)
2.lisp:  (defun make-dbms (db) 
2.lisp:  (defun lookup (key db)
2.lisp:  (defun list+ (lst n)
2.lisp:  (defun count-instances (obj lsts)
2.lisp:  (defun our-length (lst)
2.lisp:  (defun our-find-if (fn lst)
2.lisp:  (defun our-length (lst)
2.lisp:  (defun triangle (n)
2.lisp:  (defun triangle-2 (n)
2.lisp:  (defun foo (x) (1+ x))
20.lisp:(defun all-identity (&rest args)
20.lisp:(defmacro =defun (name parms &body body)
20.lisp:       (defun ,f (*cont* ,@parms) ,@body))))
20.lisp:(print (macroexpand-1 '(=defun add1 (x) (=values (1+ x)))))
20.lisp:(=defun add1 (x) 
20.lisp:(=defun bar (x)
20.lisp:(=defun message ()
20.lisp:(print (macroexpand-1 '(=defun message () (=values 'hello 'there))))
20.lisp:(=defun baz ()
20.lisp:(print (macroexpand-1 '(=defun baz () (=bind (m n) (message) (=values (list m n))))))
20.lisp:(defun dft (tree)
20.lisp:(=defun dft-node (tree)
20.lisp:(=defun my-restart ()
20.lisp:(=defun dft2 (tree)
21.lisp:  `(=defun ,name ,args
21.lisp:(defun pick-process ()
21.lisp:(defun most-urgent-process ()
21.lisp:(defun arbitrator (test cont)
21.lisp:(defun setpri (n) (setf (proc-pri *proc*) n))
21.lisp:(defun halt (&optional val) (throw *halt* val))
21.lisp:(defun my-kill (&optional obj &rest args)
21.lisp:(=defun pedestrian ()
21.lisp:(defun claim (&rest f) (push f *bboard*))
21.lisp:(defun unclaim (&rest f) (pull f *bboard* :test #'equal))
21.lisp:(defun check (&rest f) (find f *bboard* :test #'equal))
21.lisp:(=defun visitor (door)
21.lisp:(=defun host (door)
21.lisp:(=defun capture (city)
21.lisp:(=defun plunder (city)
21.lisp:(defun take (c) (format t "Liberating ~A.~%" c))
21.lisp:(defun fortify (c) (format t "Rebuilding ~A.~%" c))
21.lisp:(defun loot (c) (format t "Nationalizing ~A.~%" c))
21.lisp:(defun ransom (c) (format t "Refinancing ~A.~%" c))
22.lisp:(defun cb (fn choices)
22.lisp:(defun fail ()
22.lisp:(=defun two-numbers ()
22.lisp:(=defun parlor-trick (sum)
22.lisp:(=defun descent (n1 n2)
22.lisp:(defun kids (n)
3.lisp:(defun bad-reverse (lst)
3.lisp:(defun good-reverse (lst)
4.lisp:(defun find2 (fn lst)
4.lisp:(defun last1 (lst)
4.lisp:(defun single (lst)
4.lisp:(defun append1 (lst obj)
4.lisp:(defun conc1 (lst obj)
4.lisp:(defun mklist (obj)
4.lisp:(defun longer (x y)
4.lisp:(defun filter (fn lst)
4.lisp:(defun group (source n)
4.lisp:(defun flatten (x)
4.lisp:(defun prune (test tree)
4.lisp:(defun find2 (fn lst)
4.lisp:(defun before (x y lst &key (test #'eql))
4.lisp:(defun after (x y lst &key (test #'eql))
4.lisp:(defun duplicate (obj lst &key (test #'eql))
4.lisp:(defun split-if (fn lst)
4.lisp:(defun most (fn lst)
4.lisp:(defun best (fn lst)
4.lisp:(defun mostn (fn lst)
4.lisp:(defun map0-n (fn n)
4.lisp:(defun map1-n (fn n)
4.lisp:(defun mapa-b (fn a b &optional (step 1))
4.lisp:(defun map-> (fn start test-fn succ-fn)
4.lisp:(defun mappend (fn &rest lsts)
4.lisp:(defun mapcars (fn &rest lsts)
4.lisp:(defun rmapcar (fn &rest args)
4.lisp:(defun mapa-b2 (fn a b &optional (step 1))
4.lisp:(defun readlist (&rest args)
4.lisp:(defun prompt (&rest args)
4.lisp:(defun break-loop (fn quit &rest args)
4.lisp:(defun mkstr (&rest args)
4.lisp:(defun symb (&rest args)
4.lisp:(defun reread (&rest args)
4.lisp:(defun explode (sym)
5.4.lisp:(defun compose (&rest fns)
5.4.lisp:(defun fif (if then &optional else)
5.4.lisp:(defun fint (fn &rest fns)
5.4.lisp:(defun fun (fn &rest fns)
5.5.lisp:(defun lrec (rec &optional base)
5.5.lisp:(defun our-every (predicate lst)
5.5.lisp:(defun our-find-if (fn lst)
5.5.lisp:(defun our-some (fn lst)
5.6.lisp:(defun our-copy-tree (tree)
5.6.lisp:(defun count-leaves (tree)
5.6.lisp:(defun flatten (tree)
5.6.lisp:(defun rfind-if (fn tree)
5.6.lisp:(defun ttrav (rec &optional (base #'identity))
5.6.lisp:(defun trec (rec &optional (base #'identity))
5.6.lisp:(defun rfind-if2 (fn lst)
5.lisp:(defun joiner (obj)
5.lisp:(defun join (&rest args)
5.lisp:(defun make-adder (n)
5.lisp:(defun our-complement (fn)
5.lisp:(defun funa (x) (+ x 2))
5.lisp:(defun func (x) (funcall #'funa x))
5.lisp:(defun !! (fn)
5.lisp:(defun def! (fn fn!)
5.lisp:(defun memoize (fn)
5.lisp:(defun fibonacci (n)
5.lisp:(defun fibonacci-memo (n &optional (fn #'fibonacci-memo))
6.2.lisp:(defun defnode (name conts &optional yes no)
6.3.lisp:(defun defnode (&rest args)
6.3.lisp:(defun compile-net (root)
6.lisp:(defun defnode (name conts &optional yes no)
6.lisp:(defun run-node (name)
7.lisp:(defun greet (name)
7.lisp:(defun our-macroexpand-1 (expr)
7.lisp:(defun make-initforms (bindforms)
7.lisp:(defun make-stepforms (bindforms)
