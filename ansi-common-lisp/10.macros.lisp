

(load 'unit-test.lisp)
(use-package :unit-test)

(defmacro print-code-single (body)
    `(format t "~%~S -> ~S" ',body ,body ))

(defmacro print-code (&body forms)
  `(progn ,@(mapcar #'(lambda (form) `(print-code-single ,form)) forms )))

(print (macroexpand-1 '(print-code-single (push 1 lst))))

(setf lst nil)

(print-code-single (push 1 lst))
(print-code-single lst)
(print-code-single (push 2 lst))
(print-code-single lst)

(print (macroexpand-1 '(print-code 'a 'b 'c)))

(setf lst nil)

(print-code 'a 'b 'c (push 1 lst))

(defmacro my-eval (&body body)
  `(progn
  ,@body))

(print-code 
(eval '(+ 1 2 3))
(macroexpand-1 '(defmacro-lambda print-code (print-code-result body (eval body))))
(macroexpand-1 '(print-code (eval '(+ 1 2 3))))
(setf a 0)
(incf a 1)
a
(eval '(format t "~&Hello"))
(macroexpand-1 '(my-eval (+ 1 1)))
(defmacro nil! (x)
  (list 'setf x nil))
(macroexpand-1 '(nil! x))
'(a b c)
(defmacro nil! (x)
  `(setf x nil))
(macroexpand-1 '(nil! x))
(setf lst '(a b c))
`(lst is ,lst)
`(its elements are ,@lst)
(defmacro while (test &rest body)
  `(do ()
     ((not ,test))
     ,@body))
(macroexpand-1 '(while (< x 10) (princ x) (incf x)))
(defun quicksort (vec l r)
  (format t "~%qs:~a ~a ~a" vec l r)
  (let ((i l)
        (j r)
        (pivot (svref vec (round (+ l r) 2))))
   (format t "~%i:~a j:~a pivot:~a vec:~a" i j pivot vec)
    (while (<= i j)
           (while (< (svref vec i) pivot) (incf i))
           (format t "~%i found >= ~a ~a" (svref vec i) pivot)
           (while (> (svref vec j) pivot) (decf j))
           (format t "~%j found <= ~a ~a" (svref vec j) pivot)
   (format t "~%i:~a j:~a pivot:~a vec:~a" i j pivot vec)
           (when (<= i j)
             (format t "~%swap ~a ~a" (svref vec i) (svref vec j))
             (rotatef (svref vec i) (svref vec j))
   (format t "~%i:~a j:~a pivot:~a vec:~a" i j pivot vec)
             (incf i)
             (decf j)))
    (format t "~%l: ~a j: ~a i: ~a r: ~a" l j i r)
    (format t "~%left: ~a right: ~a" (- j l) (- r i))
    (when (>= (- j l) 1) (format t "~%calling left" ) (quicksort vec l j))
    (when (>= (- r i) 1) (format t "~%calling right") (quicksort vec i r)))
  (format t "~%done ~a ~a" l r)
  vec)
(quicksort (copy-seq #( 40 30 20 10 50 70 60 )) 0 6)
(quicksort (copy-seq #( 70 30 20 40 50 60 10 )) 0 6)
(defmacro ntimes (n &rest body)
  `(do ((x 0 (+ x 1)))
     ((>= x ,n))
     ,@body))
(let ((x 10))
  (ntimes 5
          (setf x (+ x 1)))
  x)
(defmacro ntimes (n &rest body)
  (let ((g (gensym)))
    `(do ((,g 0 (+ ,g 1)))
       ((>= ,g ,n))
       ,@body)))
(let ((x 10))
  (ntimes 5
          (setf x (+ x 1)))
  x)
(macroexpand-1 '(ntimes 5 (setf x (+ x 1))))
(let ((v 10))
  (ntimes (setf v (- v 1))
          (princ ".")))
(macroexpand-1  '(ntimes (setf v (- v 1)) (princ ".")))
(defmacro ntimes (n &rest body)
  (let ((g (gensym))
        (h (gensym)))
    `(let ((,h ,n))
       (do ((,g 0 (+ ,g 1)))
         ((>= ,g ,h))
         ,@body))))
(macroexpand-1  '(ntimes (setf v (- v 1)) (princ ".")))
(let ((v 10))
  (ntimes (setf v (- v 1))
          (princ ".")))
'section-10.6-generalized-reference
(defmacro cah (lst) `(car ,lst))
(macroexpand-1 '(cah '(a b c d e f g)))
(let ((x (list 'a 'b 'c)))
  (setf (cah x) 44)
  x)
(defmacro my-incf (x &optional (y 1))
  `(setf ,x (+ ,x ,y)))

(setf lst nil)
(incf (car (push 1 lst)))
lst
(setf lst nil)
(setf (car (push 1 lst)) (1+ (car (push 1 lst))))
lst
(setf lst nil)
(my-incf (car (push 1 lst)))
lst
(macroexpand-1 '(my-incf (car (push 1 lst))))
'this-seems-to-work
(define-modify-macro our-incf (&optional (y 1)) +)
(macroexpand-1 '(our-incf (car (push 1 lst))))
(setf lst nil)
(our-incf (car (push 1 lst)))
lst
(define-modify-macro append1f (val)
                     (lambda (lst val) (append lst (list val))))
(macroexpand-1 '(append1f lst 'end))
(let ((lst '(a b c)))
  (append1f lst 'd)
  lst)
'section-10.7-macro-utilities
(defmacro for (var start stop &body body)
  (let ((gstop (gensym)))
    `(do ((,var ,start (1+ ,var))
          (,gstop ,stop))
       ((> ,var ,gstop))
       ,@body)))
(macroexpand-1 '(for x 1 10 (print 'hi)))
(ignore-errors
(for x 10 (print 'hi)))
(do ((x 1 (1+ x))
     (end 10))
     ((> x end))
     (print 'hi))
(defmacro in (obj &rest choices)
  (let ((insym (gensym)))
    `(let ((,insym ,obj))
       (or ,@(mapcar #'(lambda (c) `(eql ,insym ,c)) choices)))))
(macroexpand-1 '(in 'a 'a 'b 'c))
(in 'a 'a 'b 'c)
(defmacro random-choices (&rest exprs)
  `(case (random ,(length exprs))
     ,@(let ((key -1))
         (mapcar #'(lambda (expr)
                     `(,(incf key) ,expr))
                 exprs))))
(macroexpand-1 '(random-choices 'a 'b 'c 'd))
(random-choices 'a 'b 'c 'd)
(random-choices 'a 'b 'c 'd)
(random-choices 'a 'b 'c 'd)
(random-choices 'a 'b 'c 'd)
(random-choices 'a 'b 'c 'd)
(random-choices 'a 'b 'c 'd)

(defmacro avg  (&rest args)
  `(/ (+ ,@args) ,(length args)))

(macroexpand-1 '(avg 1 2 3 4 5))
(avg 1 2 3 4 5)

(defmacro with-gensysms (sysms &body body)
  `(let ,(mapcar #'(lambda (s)
                     `(,s (gensym)))
                 sysms)
     ,@body))

(macroexpand-1 '(with-gensysms (a b c d) (format t "~a~a~a~a" a b c d)))

(mapcar #'(lambda (s)
            `(,s (gensym))) '(a b c d))

)

(print (run-tests))

